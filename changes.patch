*** Begin Patch
*** Add File: .env.example
+# Example environment variables for Vrittera (NextLeap AI)
+# Copy this file to .env or use react-native-config / your CI secrets.
+
+API_BASE_URL=https://api.example.com
+SENTRY_DSN=
+RZP_KEY=
+S3_BUCKET_NAME=
+S3_REGION=ap-south-1
+S3_UPLOAD_PREFIX=uploads/
+NODE_ENV=development
+
+# Do NOT add API keys for OpenAI / HuggingFace here if this file ends up in the client. 
+# LLM keys MUST be stored on the server only.
+
*** End Patch
*** Begin Patch
*** Add File: src/services/api.ts
+/* eslint-disable @typescript-eslint/no-explicit-any */
+import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
+
+// Simple API service wrapper. Keeps all network logic in one place.
+// NOTE: For React Native, you may want to map envs via react-native-config or
+// use a build-time env substitution. For now, it reads from process.env.
+
+const BASE_URL = process.env.API_BASE_URL || 'https://api.example.com';
+
+class ApiService {
+  private client: AxiosInstance;
+
+  constructor(baseURL = BASE_URL) {
+    this.client = axios.create({
+      baseURL,
+      timeout: 15000,
+      headers: {
+        'Content-Type': 'application/json',
+      },
+    });
+
+    // Request interceptor to add JWT if present
+    this.client.interceptors.request.use(async (config) => {
+      try {
+        // Replace with your auth token retrieval
+        const token = await this.getAuthToken();
+        if (token && config && config.headers) {
+          config.headers.Authorization = `Bearer ${token}`;
+        }
+      } catch (err) {
+        // ignore
+      }
+      return config;
+    });
+
+    // Response interceptor - place for central error handling / telemetry
+    this.client.interceptors.response.use(
+      (res) => res,
+      async (error) => {
+        // Simple retry logic for idempotent GETs and network errors
+        const { config } = error;
+        if (!config) return Promise.reject(error);
+
+        config.__retryCount = config.__retryCount || 0;
+        const MAX_RETRIES = 2;
+        if (config.__retryCount < MAX_RETRIES && this.isRetryable(error)) {
+          config.__retryCount += 1;
+          await this.wait(300 * config.__retryCount);
+          return this.client(config);
+        }
+        return Promise.reject(error);
+      }
+    );
+  }
+
+  private isRetryable(error: any): boolean {
+    if (!error || !error.code) return false;
+    // Retry on network errors/timeouts
+    return ['ECONNABORTED', 'ETIMEDOUT', 'ENETUNREACH'].includes(error.code) || !error.response;
+  }
+
+  private wait(ms: number) {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+  }
+
+  private async getAuthToken(): Promise<string | null> {
+    // TODO: replace this stub with your secure token storage (SecureStore, Keychain, etc.)
+    try {
+      // e.g., return await SecureStore.getItemAsync('access_token');
+      return null;
+    } catch {
+      return null;
+    }
+  }
+
+  public get<T = any>(url: string, config?: AxiosRequestConfig) {
+    return this.client.get<T>(url, config).then((r: AxiosResponse<T>) => r.data);
+  }
+
+  public post<T = any>(url: string, data?: any, config?: AxiosRequestConfig) {
+    return this.client.post<T>(url, data, config).then((r: AxiosResponse<T>) => r.data);
+  }
+
+  public put<T = any>(url: string, data?: any, config?: AxiosRequestConfig) {
+    return this.client.put<T>(url, data, config).then((r: AxiosResponse<T>) => r.data);
+  }
+
+  public delete<T = any>(url: string, config?: AxiosRequestConfig) {
+    return this.client.delete<T>(url, config).then((r: AxiosResponse<T>) => r.data);
+  }
+}
+
+const api = new ApiService();
+export default api;
+
*** End Patch
*** Begin Patch
*** Add File: src/components/AudioRecorder.tsx
+import React, { useState, useRef } from 'react';
+import { View, Text, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
+import AudioRecorderPlayer, {
+  AVEncoderAudioQualityIOSType,
+  AVEncodingOption,
+  AudioSet,
+  AudioEncoderAndroidType,
+  AudioSourceAndroidType,
+} from 'react-native-audio-recorder-player';
+import RNFS from 'react-native-fs';
+import api from '../services/api';
+
+type Props = {
+  onUploadComplete?: (fileUrl: string) => void;
+};
+
+const audioRecorderPlayer = new AudioRecorderPlayer();
+
+const AudioRecorder: React.FC<Props> = ({ onUploadComplete }) => {
+  const [recording, setRecording] = useState(false);
+  const [loading, setLoading] = useState(false);
+  const [filePath, setFilePath] = useState<string | null>(null);
+
+  const startRecording = async () => {
+    try {
+      const dirs = RNFS.TemporaryDirectoryPath || RNFS.CachesDirectoryPath;
+      const path = `${dirs}/vrittera-${Date.now()}.m4a`;
+
+      const audioSet: AudioSet = {
+        AudioEncoderAndroid: AudioEncoderAndroidType.AAC,
+        AudioSourceAndroid: AudioSourceAndroidType.MIC,
+        AVEncoderAudioQualityKeyIOS: AVEncoderAudioQualityIOSType.high,
+        AVNumberOfChannelsKeyIOS: 2,
+        AVFormatIDKeyIOS: AVEncodingOption.aac,
+      };
+
+      const result = await audioRecorderPlayer.startRecorder(path, audioSet);
+      audioRecorderPlayer.addRecordBackListener((e) => {
+        // noop; could update elapsed time here
+        return;
+      });
+
+      setFilePath(result);
+      setRecording(true);
+    } catch (err) {
+      Alert.alert('Recording error', String(err));
+    }
+  };
+
+  const stopRecording = async () => {
+    try {
+      const result = await audioRecorderPlayer.stopRecorder();
+      audioRecorderPlayer.removeRecordBackListener();
+      setRecording(false);
+      setFilePath(result);
+    } catch (err) {
+      Alert.alert('Stop error', String(err));
+    }
+  };
+
+  const uploadRecording = async () => {
+    if (!filePath) return Alert.alert('No recording', 'Please record audio first.');
+    setLoading(true);
+    try {
+      const filename = filePath.split('/').pop() || `vrittera-${Date.now()}.m4a`;
+
+      // Request presigned URL from backend
+      const presignResp = await api.post('/v1/uploads/presign', {
+        filename,
+        contentType: 'audio/m4a',
+      });
+
+      const { uploadUrl, fileUrl } = presignResp;
+      if (!uploadUrl) throw new Error('No upload URL returned from server');
+
+      // Read file as binary
+      const fileStat = await RNFS.stat(filePath);
+      const file = await RNFS.readFile(filePath, 'base64');
+
+      // PUT to presigned URL
+      const res = await fetch(uploadUrl, {
+        method: 'PUT',
+        headers: {
+          'Content-Type': 'audio/m4a',
+        },
+        body: Buffer.from(file, 'base64'),
+      });
+      if (!res.ok) {
+        throw new Error(`Upload failed: ${res.status}`);
+      }
+
+      // Notify backend to process the file (optional)
+      await api.post('/v1/interviews', {
+        fileUrl,
+        metadata: { source: 'mobile' },
+      });
+
+      onUploadComplete && onUploadComplete(fileUrl);
+      Alert.alert('Upload complete', 'Your recording was uploaded successfully.');
+    } catch (err) {
+      Alert.alert('Upload error', String(err));
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return (
+    <View style={{ padding: 16, alignItems: 'center' }}>
+      <Text style={{ marginBottom: 12 }}>{recording ? 'Recording...' : 'Ready to record'}</Text>
+      <View style={{ flexDirection: 'row', gap: 12 }}>
+        {!recording ? (
+          <TouchableOpacity
+            onPress={startRecording}
+            style={{ padding: 12, backgroundColor: '#007bff', borderRadius: 8 }}
+          >
+            <Text style={{ color: 'white' }}>Record</Text>
+          </TouchableOpacity>
+        ) : (
+          <TouchableOpacity
+            onPress={stopRecording}
+            style={{ padding: 12, backgroundColor: '#dc3545', borderRadius: 8 }}
+          >
+            <Text style={{ color: 'white' }}>Stop</Text>
+          </TouchableOpacity>
+        )}
+
+        <TouchableOpacity
+          onPress={uploadRecording}
+          disabled={loading || recording || !filePath}
+          style={{
+            padding: 12,
+            backgroundColor: loading || !filePath ? '#6c757d' : '#28a745',
+            borderRadius: 8,
+            marginLeft: 8,
+          }}
+        >
+          {loading ? <ActivityIndicator color="white" /> : <Text style={{ color: 'white' }}>Upload</Text>}
+        </TouchableOpacity>
+      </View>
+      {filePath ? <Text style={{ marginTop: 12, fontSize: 12 }}>{filePath}</Text> : null}
+    </View>
+  );
+};
+
+export default AudioRecorder;
+
*** End Patch
*** Begin Patch
*** Update File: package.json
@@
   "scripts": {
+    "android:debug": "npx react-native run-android",
+    "ios:debug": "npx react-native run-ios",
     "test": "jest",
     "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
     "format": "prettier --write ."
   },
@@
-  "dependencies": {
+  "dependencies": {
     "react": "18.2.0",
     "react-native": "0.71.8",
+    "axios": "^1.4.0",
+    "react-native-audio-recorder-player": "^3.5.2",
     ...
   },
*** End Patch
